%prefix "parser"

%value "AstNodeC"
%auxil "SourceC"

%header {
#include "c_api.h"
//~ #include "source.h"
//~ #include "ast.h"
/*
static const char *dbg_str[] = { "Evaluating rule", "Matched rule", "Abandoning rule" };
#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) \
    fprintf(stderr, "%*s%s %s @%zu [%.*s]\n", (int)((level) * 2), "", dbg_str[event], rule, pos, (int)(length), buffer)
*/
}

%source {
#define PCC_GETCHAR(auxil) source_read(auxil)
}

grammar <- _* l:statement_list _* <c:code?> EOF
    {
        $$ = l;
        if ($1s != $1e) append_child($$, c);
    }

statement_list
   <- s:statement _ l:statement_list
    {
        $$ = l;
        prepend_child($$, s);
    }
    / s:statement
    {
        $$ = create_ast_node(AST_NODE_TYPE_GRAMMAR);
        prepend_child($$, s);
    }

statement
    <- r:rule { $$ = r; }
    / d:directive { $$ = d; }
    / c:comment { $$ = c; }

rule <- <identifier> _ '<-' _ a:alternation
    {
        AstNodeC name = create_ast_leaf(auxil, AST_NODE_TYPE_RULE_NAME, $1, $1s);
        $$ = create_ast_node(AST_NODE_TYPE_RULE);
        append_child($$, name);
        append_child($$, a);
    }

directive <-
    '%' <"value" / "auxil" / "prefix"> _ s:string
    {
        AstNodeC name = create_ast_leaf(auxil, AST_NODE_TYPE_DIRECTIVE_NAME, $1, $1s);
        $$ = create_ast_node(AST_NODE_TYPE_DIRECTIVE);
        append_child($$, name);
        append_child($$, s);
    }
    / '%' <"header" / "source" / "common" / "earlyheader" / "earlysource" / "earlycommon"> _ s:source
    {
        AstNodeC name = create_ast_leaf(auxil, AST_NODE_TYPE_DIRECTIVE_NAME, $2, $2s);
        $$ = create_ast_node(AST_NODE_TYPE_DIRECTIVE);
        append_child($$, name);
        append_child($$, s);
    }

code <- '%%' [ \t\r\n]* <.*> { $$ = create_ast_leaf(auxil, AST_NODE_TYPE_CODE, $1, $1s); }

alternation
    <- s:sequence _* "/" _* a:alternation
    {
        $$ = a;
        prepend_child($$, s);
    }
    / s:sequence
    {
        $$ = create_ast_node(AST_NODE_TYPE_ALTERNATION);
        prepend_child($$, s);
    }

sequence
    <- p:primary _* s:sequence
    {
        $$ = s;
        prepend_child($$, p);
    }
    / p:primary
    {
        $$ = create_ast_node(AST_NODE_TYPE_SEQUENCE);
        prepend_child($$, p);
    }

primary <- ( <pr:prefixOp?> l:literal <po:postfixOp?> (_* <s:source>)? )
    {
        $$ = create_ast_node(AST_NODE_TYPE_PRIMARY);
        if ($1s != $1e) append_child($$, pr);
        append_child($$, l);
        if ($2s != $2e) append_child($$, po);
        if ($3s != $3e) append_child($$, s);
    }

literal
    <- r:ruleref { $$ = r; }
    / s:string { $$ = s; }
    / cc:charClass { $$ = cc; }
    / c:comment { $$ = c; }
    / '.' { $$ = create_ast_leaf(auxil, AST_NODE_TYPE_DOT, $0, $0s); }
    / '$' [1-9][0-9]* { $$ = create_ast_leaf(auxil, AST_NODE_TYPE_BACKREF, $0, $0s); }
    / '<' _* a:alternation _* '>' { $$ = create_ast_node(AST_NODE_TYPE_CAPTURE); append_child($$, a); }
    / '(' _* a:alternation _* ')' { $$ = create_ast_node(AST_NODE_TYPE_GROUP); append_child($$, a); }

string
    <- '"' <("\\" . / [^"])*> '"' { $$ = create_ast_leaf(auxil, AST_NODE_TYPE_STRING, $1, $1s); }
    / "'" <("\\" . / [^'])*> "'" { $$ = create_ast_leaf(auxil, AST_NODE_TYPE_STRING, $2, $2s); }

source <- '{' <([^{}]* source?)*> '}' { $$ = create_ast_leaf(auxil, AST_NODE_TYPE_SOURCE, $1, $1s); }

character <- "\\" . / [^\]]
charClass <- "[" "^"? (character ("-" character)?)+ "]" { $$ = create_ast_leaf(auxil, AST_NODE_TYPE_CHARCLASS, $0, $0s); }

identifier <- [_a-zA-Z][_a-zA-Z0-9]*
ruleref
    <- <identifier> ':' <identifier> !( _* "<-")
    {
        $$ = create_ast_leaf(auxil, AST_NODE_TYPE_RULEREF, $2, $2s);
        append_child($$, create_ast_leaf(auxil, AST_NODE_TYPE_VAR, $1, $1s));
    }
    / <identifier> !( _* "<-")
    {
        $$ = create_ast_leaf(auxil, AST_NODE_TYPE_RULEREF, $3, $3s);
    }

prefixOp <- [&!] { $$ = create_ast_leaf(auxil, AST_NODE_TYPE_PREFIX_OP, $0, $0s); }
postfixOp <- [?*+] { $$ = create_ast_leaf(auxil, AST_NODE_TYPE_POSTFIX_OP, $0, $0s); }

comment <- _* '#'+ [ \t]* <[^\n]*> {
    $$ = create_ast_leaf(auxil, AST_NODE_TYPE_COMMENT, $1, $1s);
}
_ <- [ \t\r\n]+
EOF <- !.
